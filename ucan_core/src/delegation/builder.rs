//! Typesafe builder for [`Delegation`].

use super::{policy::predicate::Predicate, subject::DelegatedSubject};
use crate::{
    crypto::nonce::Nonce,
    did::{Did, DidSigner},
    envelope::{Envelope, EnvelopePayload},
    sealed::{CommandOrUnset, DelegatedSubjectOrUnset, DidOrUnset, DidSignerOrUnset},
    time::timestamp::Timestamp,
    unset::Unset,
};
use ipld_core::ipld::Ipld;
use serde::{Deserialize, Serialize};
use serde_ipld_dagcbor::{codec::DagCborCodec, error::CodecError};
use std::{collections::BTreeMap, marker::PhantomData};
use varsig::{signer::SignerError, Varsig};

/// Typesafe builder for [`Delegation`].
#[derive(Default, Debug, Clone)]
pub struct DelegationBuilder<
    D: Did,
    Issuer: DidSignerOrUnset = Unset,
    Audience: DidOrUnset = Unset,
    Subject: DelegatedSubjectOrUnset = Unset,
    Command: CommandOrUnset = Unset,
> {
    /// Issuer of the delegation.
    pub issuer: Issuer,

    /// Audience of the delegation.
    pub audience: Audience,

    /// Subject of the delegation (the resource or object being accessed).
    pub subject: Subject,

    /// Command of the delegation (similar to a function name).
    pub command: Command,

    /// Policy of the delegation.
    ///
    /// A list of predicates that the [`Invocation`] arguments must satisfy.
    pub policy: Vec<Predicate>,

    /// Expiration time of the delegation.
    pub expiration: Option<Timestamp>,

    /// Earliest time a delegation can be used.
    pub not_before: Option<Timestamp>,

    /// Extensible metadata for the delegation.
    pub meta: BTreeMap<String, Ipld>,

    /// Nonce (will be autogenerated if left blank).
    pub nonce: Option<Nonce>,

    _did: PhantomData<D>,
}

impl<D: Did> DelegationBuilder<D> {
    /// Creates a blank [`DelegationBuilder`] instance.
    #[must_use]
    pub const fn new() -> Self {
        Self {
            issuer: Unset,
            audience: Unset,
            subject: Unset,
            command: Unset,
            policy: Vec::new(),
            expiration: None,
            not_before: None,
            meta: BTreeMap::new(),
            nonce: None,
            _did: PhantomData,
        }
    }
}

impl<
        D: Did,
        Issuer: DidSignerOrUnset,
        Audience: DidOrUnset,
        Subject: DelegatedSubjectOrUnset,
        Command: CommandOrUnset,
    > DelegationBuilder<D, Issuer, Audience, Subject, Command>
{
    /// Sets the `issuer` field of the delegation.
    #[must_use]
    pub fn issuer<I: DidSigner<Did = D>>(
        self,
        issuer: I,
    ) -> DelegationBuilder<D, I, Audience, Subject, Command> {
        DelegationBuilder {
            issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `audience` field of the delegation.
    #[must_use]
    pub fn audience(self, audience: D) -> DelegationBuilder<D, Issuer, D, Subject, Command> {
        DelegationBuilder {
            issuer: self.issuer,
            audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `subject` field of the delegation.
    #[must_use]
    pub fn subject(
        self,
        subject: DelegatedSubject<D>,
    ) -> DelegationBuilder<D, Issuer, Audience, DelegatedSubject<D>, Command> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `command` field of the delegation.
    #[must_use]
    pub fn command(
        self,
        command: Vec<String>,
    ) -> DelegationBuilder<D, Issuer, Audience, Subject, Vec<String>> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `policy` field of the delegation.
    #[must_use]
    pub fn policy(
        self,
        policy: Vec<Predicate>,
    ) -> DelegationBuilder<D, Issuer, Audience, Subject, Command> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `expiration` field of the delegation.
    #[must_use]
    pub fn expiration(
        self,
        expiration: Timestamp,
    ) -> DelegationBuilder<D, Issuer, Audience, Subject, Command> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: Some(expiration),
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `not_before` field of the delegation.
    #[must_use]
    pub fn not_before(
        self,
        not_before: Timestamp,
    ) -> DelegationBuilder<D, Issuer, Audience, Subject, Command> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: Some(not_before),
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `meta` field of the delegation.
    #[must_use]
    pub fn meta(
        self,
        meta: BTreeMap<String, Ipld>,
    ) -> DelegationBuilder<D, Issuer, Audience, Subject, Command> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `nonce` field of the delegation.
    #[must_use]
    pub fn nonce(self, nonce: Nonce) -> DelegationBuilder<D, Issuer, Audience, Subject, Command> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: Some(nonce),
            _did: PhantomData,
        }
    }
}

#[allow(clippy::mismatching_type_param_order)]
impl<D: Clone + Did + Serialize + for<'de> Deserialize<'de>, Issuer: DidSigner<Did = D>>
    DelegationBuilder<D, Issuer, D, DelegatedSubject<D>, Vec<String>>
{
    /// Builds an (unsigned) [`DelegationPayload`].
    ///
    /// This is typesafe, and only possible to call when all required fields are set.
    ///
    /// # Panics
    ///
    /// Panics if random number generator fails when generating a nonce.
    /// This will never happen if a nonce is provided, and is not recoverable
    /// becuase a broken RNG is a serious problem.
    #[allow(clippy::expect_used)]
    pub fn build_payload(self) -> super::DelegationPayload<D> {
        super::DelegationPayload {
            issuer: self.issuer.did().clone(),
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self
                .nonce
                .unwrap_or_else(|| Nonce::generate_16().expect("failed to generate nonce")),
        }
    }

    /// Builds the complete, signed [`Delegation`].
    ///
    /// # Errors
    ///
    /// * `SignerError` if signing the delegation fails.
    ///
    /// # Panics
    ///
    /// Panics if random number generator fails when generating a nonce.
    /// This will never happen if a nonce is provided, and is not recoverable
    /// becuase a broken RNG is a serious problem.
    #[allow(clippy::expect_used)]
    pub fn try_build(
        self,
    ) -> Result<super::Delegation<Issuer, D>, SignerError<CodecError, Issuer::SignError>> {
        let payload: super::DelegationPayload<D> = super::DelegationPayload {
            issuer: self.issuer.did().clone(),
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self
                .nonce
                .unwrap_or_else(|| Nonce::generate_16().expect("failed to generate nonce")),
        };

        let (sig, _) = self
            .issuer
            .try_sign(&DagCborCodec, &self.issuer.signer(), &payload)?;

        let header: Varsig<Issuer, DagCborCodec, super::DelegationPayload<D>> =
            Varsig::new(self.issuer, DagCborCodec);

        Ok(super::Delegation(Envelope(
            sig,
            EnvelopePayload { header, payload },
        )))
    }
}
