//! Typesafe builder for [`InvocationPayload`].

use crate::{
    builder::AsyncBuildError,
    command::Command,
    crypto::nonce::Nonce,
    did::{AsyncDidSigner, Did, DidSigner},
    envelope::{Envelope, EnvelopePayload},
    promise::Promised,
    sealed::{CommandOrUnset, DidOrUnset, DidSignerOrUnset, ProofsOrUnset},
    time::timestamp::Timestamp,
    unset::Unset,
};
use ipld_core::{cid::Cid, ipld::Ipld};
use serde_ipld_dagcbor::codec::DagCborCodec;
use signature::SignatureEncoding;
use std::{collections::BTreeMap, marker::PhantomData};
use varsig::{verify::Verify, Varsig};

/// Typesafe builder for [`Delegation`].
#[allow(private_bounds)]
#[derive(Default, Debug, Clone)]
pub struct InvocationBuilder<
    D: DidSigner,
    Issuer: DidSignerOrUnset = Unset,
    Audience: DidOrUnset = Unset,
    Subject: DidOrUnset = Unset,
    Cmd: CommandOrUnset = Unset,
    Proofs: ProofsOrUnset = Unset,
> {
    /// Issuer of the invocation.
    pub issuer: Issuer,

    /// Audience of the invocation.
    pub audience: Audience,

    /// Subject of the invocation (the resource or object being accessed).
    pub subject: Subject,

    /// Cmd being invoked.
    pub command: Cmd,

    /// The arguments for the Cmd.
    pub arguments: BTreeMap<String, Promised>,

    /// Proofs of the invocation.
    pub proofs: Proofs,

    /// Cause of the invocation.
    pub cause: Option<Cid>,

    /// Expiration time of the invocation.
    pub expiration: Option<Timestamp>,

    /// The time at which this invocation claims to have been issued.
    pub issued_at: Option<Timestamp>,

    /// Extensible metadata for the delegation.
    pub meta: BTreeMap<String, Ipld>,

    /// Nonce (will be autogenerated if left blank).
    pub nonce: Option<Nonce>,

    _did: PhantomData<D>,
}

impl<D: DidSigner> InvocationBuilder<D, Unset, Unset, Unset, Unset, Unset> {
    /// Creates a blank [`InvocationBuilder`] instance.
    #[must_use]
    pub const fn new() -> Self {
        Self {
            issuer: Unset,
            audience: Unset,
            subject: Unset,
            command: Unset,
            arguments: BTreeMap::new(),
            proofs: Unset,
            cause: None,
            expiration: None,
            issued_at: None,
            meta: BTreeMap::new(),
            nonce: None,
            _did: PhantomData,
        }
    }
}

#[allow(private_bounds)]
impl<
        D: DidSigner,
        Issuer: DidSignerOrUnset,
        Audience: DidOrUnset,
        Subject: DidOrUnset,
        Cmd: CommandOrUnset,
        Proofs: ProofsOrUnset,
    > InvocationBuilder<D, Issuer, Audience, Subject, Cmd, Proofs>
{
    /// Sets the `issuer` field of the invocation.
    #[must_use]
    pub fn issuer(self, issuer: D) -> InvocationBuilder<D, D, Audience, Subject, Cmd, Proofs> {
        InvocationBuilder {
            issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            arguments: self.arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: self.issued_at,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `audience` field of the invocation.
    #[must_use]
    pub fn audience(
        self,
        audience: D::Did,
    ) -> InvocationBuilder<D, Issuer, D::Did, Subject, Cmd, Proofs> {
        InvocationBuilder {
            issuer: self.issuer,
            audience,
            subject: self.subject,
            command: self.command,
            arguments: self.arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: self.issued_at,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `subject` field of the invocation.
    #[must_use]
    pub fn subject(
        self,
        subject: D::Did,
    ) -> InvocationBuilder<D, Issuer, Audience, D::Did, Cmd, Proofs> {
        InvocationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject,
            command: self.command,
            arguments: self.arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: self.issued_at,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `command` field of the invocation.
    #[must_use]
    pub fn command(
        self,
        command: Vec<String>,
    ) -> InvocationBuilder<D, Issuer, Audience, Subject, Command, Proofs> {
        InvocationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: Command::new(command),
            arguments: self.arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: self.issued_at,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `arguments` field of the invocation.
    #[must_use]
    pub fn arguments(
        self,
        arguments: BTreeMap<String, Promised>,
    ) -> InvocationBuilder<D, Issuer, Audience, Subject, Cmd, Proofs> {
        InvocationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: self.issued_at,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `proofs` field of the invocation.
    #[must_use]
    pub fn proofs(
        self,
        proofs: Vec<Cid>,
    ) -> InvocationBuilder<D, Issuer, Audience, Subject, Cmd, Vec<Cid>> {
        InvocationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            arguments: self.arguments,
            proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: self.issued_at,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `expiration` field of the invocation.
    #[must_use]
    pub fn expiration(
        self,
        expiration: Timestamp,
    ) -> InvocationBuilder<D, Issuer, Audience, Subject, Cmd, Proofs> {
        InvocationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            arguments: self.arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: Some(expiration),
            issued_at: self.issued_at,
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `issued_at` field of the invocation.
    #[must_use]
    pub fn issued_at(
        self,
        issued_at: Timestamp,
    ) -> InvocationBuilder<D, Issuer, Audience, Subject, Cmd, Proofs> {
        InvocationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            arguments: self.arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: Some(issued_at),
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `issued_at` field of the invocation to the current system time.
    #[must_use]
    pub fn issue_now(self) -> InvocationBuilder<D, Issuer, Audience, Subject, Cmd, Proofs> {
        InvocationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            arguments: self.arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: Some(Timestamp::now()),
            meta: self.meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `meta` field of the invocation.
    #[must_use]
    pub fn meta(
        self,
        meta: BTreeMap<String, Ipld>,
    ) -> InvocationBuilder<D, Issuer, Audience, Subject, Cmd, Proofs> {
        InvocationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            arguments: self.arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: self.issued_at,
            meta,
            nonce: self.nonce,
            _did: PhantomData,
        }
    }

    /// Sets the `nonce` field of the invocation.
    #[must_use]
    pub fn nonce(
        self,
        nonce: Nonce,
    ) -> InvocationBuilder<D, Issuer, Audience, Subject, Cmd, Proofs> {
        InvocationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            arguments: self.arguments,
            proofs: self.proofs,
            cause: self.cause,
            expiration: self.expiration,
            issued_at: self.issued_at,
            meta: self.meta,
            nonce: Some(nonce),
            _did: PhantomData,
        }
    }
}

/// Building methods that use async signing.
///
/// This impl block uses async signing via [`AsyncDidSigner`], which works with
/// both native `ed25519_dalek` signers and `WebCrypto` signers in WASM environments.
/// It doesn't require the issuer type to implement `Serialize`, making it compatible
/// with `WebCryptoEd25519Signer` (since `CryptoKey` is not serializable).
#[allow(clippy::mismatching_type_param_order)]
impl<D: DidSigner> InvocationBuilder<D, D, D::Did, D::Did, Command, Vec<Cid>> {
    /// Builds the complete, signed [`Invocation`].
    ///
    /// This method works with any signer implementing [`AsyncDidSigner`], including
    /// native `ed25519_dalek` signers and `WebCrypto` signers in WASM environments.
    ///
    /// # Type Parameters
    ///
    /// * `S` - A signer that implements [`AsyncDidSigner`] with a matching DID type
    ///
    /// # Errors
    ///
    /// * `AsyncBuildError::EncodingError` if encoding the payload fails
    /// * `AsyncBuildError::SigningError` if signing fails
    ///
    /// # Panics
    ///
    /// Panics if random number generator fails when generating a nonce.
    /// This will never happen if a nonce is provided, and is not recoverable
    /// because a broken RNG is a serious problem.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let signer = Ed25519Signer::new(signing_key);
    /// let invocation = InvocationBuilder::new()
    ///     .issuer(signer.clone())
    ///     .audience(audience_did)
    ///     .subject(subject_did)
    ///     .command(vec!["storage".into(), "read".into()])
    ///     .proofs(vec![delegation_cid])
    ///     .try_build(&signer)
    ///     .await?;
    /// ```
    #[allow(clippy::expect_used)]
    pub async fn try_build<S>(
        self,
        signer: &S,
    ) -> Result<super::Invocation<D::Did>, AsyncBuildError<S::SignError>>
    where
        S: AsyncDidSigner<
            Did = D::Did,
            Signature = <<D::Did as Did>::VarsigConfig as Verify>::Signature,
        >,
        S::Signature: SignatureEncoding,
    {
        let payload: super::InvocationPayload<D::Did> = super::InvocationPayload {
            issuer: self.issuer.did().clone(),
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            arguments: self.arguments,
            expiration: self.expiration,
            issued_at: self.issued_at,
            proofs: self.proofs,
            cause: self.cause,
            meta: self.meta,
            nonce: self
                .nonce
                .unwrap_or_else(|| Nonce::generate_16().expect("failed to generate nonce")),
        };

        // Encode the payload
        let encoded = serde_ipld_dagcbor::to_vec(&payload)
            .map_err(|e| AsyncBuildError::EncodingError(e.to_string()))?;

        // Sign the encoded payload
        let sig = signer
            .sign(&encoded)
            .await
            .map_err(AsyncBuildError::SigningError)?;

        let header: Varsig<
            <D::Did as Did>::VarsigConfig,
            DagCborCodec,
            super::InvocationPayload<D::Did>,
        > = Varsig::new(self.issuer.did().varsig_config().clone(), DagCborCodec);

        let payload: EnvelopePayload<
            <D::Did as Did>::VarsigConfig,
            super::InvocationPayload<D::Did>,
        > = EnvelopePayload { header, payload };

        #[allow(clippy::type_complexity)]
        let envelope: Envelope<
            <D::Did as Did>::VarsigConfig,
            super::InvocationPayload<D::Did>,
            S::Signature,
        > = Envelope(sig, payload);

        let invocation: super::Invocation<D::Did> = super::Invocation(envelope);

        Ok(invocation)
    }
}
